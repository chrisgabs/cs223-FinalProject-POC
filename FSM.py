class TSAFM_Ordinances:
    """
    Implementation of a Non-Deterministic Transition-Assigned Finite State Machine (Mealy Automaton)

    where:
    Q - Set of states
    S - input alphabet
    R - output alphabet
    f - state transition function (Q x S -> Q)
    g - output function (Q x S -> R)
    qi - initial state
    """

    def __init__(self, Q, S, R, f, g, qi):
        self.Q = Q
        self.S = S
        self.R = R
        self.f = f
        self.g = g
        self.q0 = qi

    def run(self, input_str):
        """
        Processes an input string and returns the output generated by the FSM.

        Returns:
        - output: the output generated by the FSM for the input string
        """
        q = self.q0
        ordinance_codes = []
        candidate_string = ""
        for symbol_raw in input_str.split(" "):
            token = None
            symbol = symbol_raw.lower()

            if symbol in self.S:
                token = symbol
            elif len(symbol) > 1:
                if (symbol.isdigit() or symbol[:-1].isdigit()) and symbol[-2].isdigit():
                    token = "_%number%_"

            q_next = self.f.get((q, token), None)
            if q_next is None:
                q = "A"
                candidate_string = ""
                continue

            if q_next == "A":
                # Remove trailing comma or period in year if there is any
                if symbol[-1] == "," or symbol[-1] == ".":
                    symbol_raw = symbol_raw[:-1]
                candidate_string += symbol_raw + " "
                ordinance_codes.append(candidate_string.strip())
                candidate_string = ""
                q = q_next
                pass

            # If there is a new state, then append current word to 
            # candidate_string
            candidate_string += symbol_raw + " "
            q = q_next

        return ordinance_codes


# ordinances
fsm_ordinances = TSAFM_Ordinances(
    Q = {'A', 'B', 'C', 'D', 'E', 'F', 'G'},
    S = {'ordinance', 'no.', '_%number%_', 'series', 'of', ''},
    R = {True, False},
    f = {('A', 'ordinance'): 'B', ('B', 'no.'): 'C', ('C', '_%number%_'): 'D', ('D', 'series'): 'E', ('E', 'of'): 'G', ('G', '_%number%_'): 'A'},
    g = {('A', 'ordinance'): True, ('B', 'no.'): True, ('C', '_%number%_'): True, ('D', 'series'): True, ('E', 'of'): True, ('G', '_%number%_'): True}, 
    qi ='A')


# --------------------------------------------------------------------------------


# resolutions
fsm_resolutions = TSAFM_Ordinances(
    {'A', 'B', 'C', 'D', 'E', 'F', 'G'},
    {'resolution', 'no.', '_%number%_', 'series', 'of', ''},
    {True, False},
    {('A', 'resolution'): 'B', ('B', 'no.'): 'C', ('C', '_%number%_'): 'D', ('D', 'series'): 'E', ('E', 'of'): 'G', ('G', '_%number%_'): 'A'},
    {('A', 'resolution'): True, ('B', 'no.'): True, ('C', '_%number%_'): True, ('D', 'series'): True, ('E', 'of'): True, ('G', '_%number%_'): True},
    'A')


# --------------------------------------------------------------------------------

from unidecode import unidecode

class FSA_CandidateTitleToken:
    def __init__(self, Q, S, R, f, g, qi):
        self.Q = Q
        self.S = S
        self.R = R
        self.f = f
        self.g = g
        self.q0 = qi

    def run(self, input_str):
        q = self.q0
        out = 0
        for token in input_str:
            # standardize font style
            token = unidecode(token)
            # check if character is lower alphabet
            if ord(token) > 96 and ord(token) < 123:
                token = "lower"
            # check if character is upper alphabet
            elif ord(token) > 64 and ord(token) < 91:
                token = "upper"
            # check if character is numerical
            elif ord(token) > 47 and ord(token) < 58:
                token = "numnerical"
            # else, character is special character
            else:
                token = "special"
            q_next = self.f.get((q, token), None)
            out = self.g.get((q, token), None)
            q = q_next
            if out == False:
                return False
        return True
    

# Define the parameters for the TSAFM
Q = {'A', 'B', 'C'}
S = {"lower", "upper", "numerical", "special"}
R = {True, False}
f = {('A', 'lower'): 'A', ('A', 'upper'): 'B', ('A', 'numerical'): 'B', ('A', 'special'): 'C', 
     ('B', 'upper'): 'B', ('B', 'numerical'): 'B', ('B', 'special'): 'B', ('B', 'lower'): 'A', 
     ('C', 'lower'): 'A', ('C', 'upper'): 'B', ('C', 'numerical'): 'B', ('C', 'special'): 'C'}
g = {('A', 'lower'): False, ('A', 'upper'): True, ('A', 'numerical'): True, ('A', 'special'): False, 
     ('B', 'upper'): True, ('B', 'numerical'): True, ('B', 'special'): True, ('B', 'lower'): False, 
     ('C', 'lower'): False, ('C', 'upper'): True, ('C', 'numerical'): True, ('C', 'special'): False}
qi = 'A'

# Create an instance of the TSAFM
fsm_candidates = FSA_CandidateTitleToken(Q, S, R, f, g, qi)


# --------------------------------------------------------------------------------

class FSA_Title:
    def __init__(self, Q, S, R, f, g, qi):
        self.Q = Q
        self.S = S
        self.R = R
        self.f = f
        self.g = g
        self.q0 = qi

    def run(self, input_str, fsa_validator):
        q = self.q0
        candidate_words = ""
        for token in input_str.split(" "):
            is_candidate = "valid" if fsa_validator.run(token) else "invalid"
            q_next = self.f.get((q, is_candidate), None)
            out = self.g.get((q, is_candidate), None)
            if out == "0":
                candidate_words = ""
            elif out == "1":
                candidate_words += token + " "
            else:
                return candidate_words.strip()
            q = q_next
    

# Define the parameters for the TSAFM
Q = {'A', 'B', 'C', 'D'}
S = {'valid', 'invalid'}
R = {'0', '1', '2'}
f = {('A', 'valid'): 'B', ('A', 'invalid'): 'A', 
     ('B', 'valid'): 'C', ('B', 'invalid'): 'A',
     ('C', 'valid'): 'C', ('C', 'invalid'): 'D',
     ('D', 'valid'): 'A', ('D', 'invalid'): 'A',}
g = {('A', 'valid'): '1', ('A', 'invalid'): '0', 
     ('B', 'valid'): '1', ('B', 'invalid'): '0',
     ('C', 'valid'): '1', ('C', 'invalid'): '2',
     ('D', 'valid'): '0', ('D', 'invalid'): '0',}
qi = 'A'

# Create an instance of the TSAFM
fsm_title = FSA_Title(Q, S, R, f, g, qi)
